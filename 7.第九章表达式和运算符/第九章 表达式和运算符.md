
# 1.表达式

表达式是一个包含了运算符和操作数的字符串。

运算符是一个单一的符号，能进行一些操作，并得到返回结果。他从操作数获得输入，进行操作并返回结果。

运算符能接受的操作数：
- 字面量
- 常量
- 变量
- 方法调用
- 元素访问器如数组访问器和索引
- 其他表达式

表达式求值的过程就是，运算符以合适的顺序得到它的操作数并得到运算结果的过程。
- 值会返回到表达式求值的位置，并在那个地方生成一个封闭的操作数
- 表达式不仅能求值，还可能会产生一些副作用，比如将一个数据存储（赋值运算表达式）

## 2.字面量

字面量指在源代码中写的具体的值，如一个数字或一个字符串。字面量具有具体的类型和数值。
其中引用类型字面量null值没有指向任何堆中的数据。


```C#
static void Main()
{
3.1416;  //双精度字面量
3.1416F;  //浮点型字面量
1024; //整数字面量
true; //bool
'x'; //char
"Hi There";  //string
}
```

### 1.整数字面量

整数字面量就是使用十进制整数来作为字面量。

整数字面量可以用以下进制书写:
- 十进制
- 十六进制  0X前缀
- 二进制 0B前缀

整数字面量有以下几种类型：

| 类型    | 存储位数 | 后缀  |
| ----- | ---- | --- |
| int   | 32位  | 无后缀 |
| uint  | 32位  | U   |
| long  | 64位  | L   |
| ulong | 64位  | UL  |

因此 整数字面量可以使用
- 前缀表示它的进制
- 后缀来表示它的类型，也即取值范围
- 当你不确定整数大小时，可以插入分割符：  5_000_000_000
- 编译器会使用一个能容纳这个值的最小类型来容纳它，如236可以用32byte表示，那么就是int类型

### 2.实数字面量(浮点数)

C#有三种实数数据类型： float， double，decimal。

实数字面量的书写形式：

| 书写方法         | 示例        |
| ------------ | --------- |
| 整数  后缀       | 5F        |
| 整数 E-n 后缀    | 3e-3 F    |
| .整数 E-n 后缀   | .5 E-3 D  |
| 整数.整数 E-n 后缀 | 3.2 E-3 M |
|              |           |

后缀说明

| 后缀  | 说明      |
| --- | ------- |
| 无   | double  |
| F   | Float   |
| D   | Double  |
| M   | Decimal |

### 3.字符字面量 char

字符字面量使用’‘来引用
字符字面量可以表示：
- 单个字符
- 非打印字符
- 执行特殊操作的字符如 '\\'-转义字符


单个字符可以任意一个字符， 反斜杠需要'\\\\' 来表示
除了单个字符，字符字面量用以下方式表示
- 简单转义序列  使用\和一个单个字符表示
- 十六进制转义字符  \X+4个十六进制的值
- Unicode转义字符  \u+4个十六进制值

示例：
```C#
char c1 = ‘d';
char c2 = '\n';
char c3 =  '\X0061'     // 十六进制转义字符
char c4 = '\u005a'   // Unicode转义字符
```

一些重要的特殊字符

| 名称    | 转义序列 | 十六进制编码 |
| ----- | ---- | ------ |
| 空字符   | \0   | 0X0000 |
| 警告    | \a   | 0X0007 |
| 退格符   | \b   | 0X0008 |
| 水平制表符 | \t   | 0X0009 |
| 换行符   | \n   | 0X000A |
| 垂直制表符 | \v   | 0X000B |
| 换页符   | \f   | 0X000C |
| 回车符   | \r   | 0X000D |
| 双引号   | \\"  | 0X0022 |
| 单引号   | \\'  | 0X0027 |
| 反斜杠   | \\\  | 0X005C |


### 4.字符串字面量

字符串字面量使用“ ” 引用的字符串，它包含两种类型：
- 普通字符串字面量
- @逐字字符串字面量


逐字字符串字面使用 @“字符串”的形式，
他的特点是不会翻译转换符，会按逐个在字符串内部的形式来打印。
例外是@“ 字符串1” “字符串 ”，相邻的字符串会被认为是一个字符串


普通字符串字面量，“ ”：
- 会将转义字符运算为对应的符号
- 将其余的字符按原样保量


相同的字符串字面量会存储到同一内存中以节省空间。

示例 ：
```C#
 
string v1 = @"value \t value \0X00A";  //此时打印时，\t 和 \0X00A会按原样打印
string v2 = "value \t value \0X00A";  //此时打印时，\t会被换成制表符，\0X00A会换成换行符
```


# 3.运算符与求值顺序

## 1.运算符的优先级与结合顺序

表达式的运算顺序要根据：
1. 运算符的优先级
2. 运算符的结合性(从左还是从左计算)
3. ( )的使用

**运算符的优先级,从高到底**

| 分类    | 运算符                                                 |
| ----- | --------------------------------------------------- |
| 初级运算符 | a.x,f(x),a\[x],x++,x--,new,typeof,checked,unchecked |
| 一元运算符 | +、-、!、 ++x 、 --x、 (T)x                              |
| 乘法    | * , / , %                                           |
| 加法    | +， -                                                |
| 位移    | << , >>                                             |
| 关系和类型 | > , <, <=, >=, is, as                               |
| 相等    | == 、!=                                              |
| 位与    | &                                                   |
| 位异或   | ^                                                   |
| 位或    | \|                                                  |
| 条件与   | &&                                                  |
| 条件或   | \|\|                                                |
| 条件选择  | ? :                                                 |
| 赋值运算  | =, *=, /= , %=, +=, -=, <<=, >>=,&=,^=,\|=          |



**运算符的结合性：**

二元元素符：
- 赋值运算符和三目条件运算符都是从右向左，右结合
- 其他二元运算符都是从左到右计算



()的使用

**()包裹的内容可以无视运算符和结合律，优先计算括号中的内容。有嵌套的话从嵌套的内层到外层。**


## 2.简单算数运算符 + -

`+ - * /`

## 3.求余运算符 %


求余也可以被称为求模， 计算可以的到余数或模。


## 4. 关系比较运算符和相等比较运算符 >

关系比较运算符是二元运算符，它的运算结果是bool值--bool或false

关系比较运算符有：
- >
- <
- >=
- <=
- ==
- !=


在C#中数字不具有bool意义

###  1.引用类型的相等性比较

对于大多数引用类型，都进行浅比较，即只比较他们的引用是否相同。
若两个引用类型的引用不同即时他们在堆中数据都相同，结果也是false。


但对于字符串是深比较， 会比较字符串的长度内容(包括大小写)是否相同。


## 5.递增和递减运算符 ++

递增运算符 即 
- --var 
- var-- 
- ++var 
- var++

他们都会在序列点返回var操作后的值，区别是
- 前置时会在运算表达式中以操作前的值计算
- 后置时会在运算表达式中以更新后的值计算


## 6.条件逻辑运算符 &&

逻辑运算符 || && ！
逻辑运算符堆操作数的bool值进行逻辑判断并返回bool值


需要注意的是二元逻辑运算符是短路模式操作：
当计算Exp1得值后能得到结果，就会跳过Exp2直接得出结果，
当操作值表达式中有副作用时，需要注意可能会被跳过


```C#
namespace Chapter_9
{
    internal class Program
    {
        static void Main()
        {
            bool bVal; int iVal = 10;

            bVal = (1 == 2) && (9 == iVal++);   // 不会计算&&右边的

            Console.WriteLine($"iVal = {iVal}");
        }
    }
}
```

`bVal = (1 == 2) && (9 == iVal++); ` 
逻辑运算符是左结合的， 当`1 == 2`的结果是false那么整个&&运算的结果也是false，
不会对`9 == iVal++`进行运算，所以iVal的值仍然是10


## 7.位逻辑运算符 |

按位逻辑运算符常用于设置位组(bit pattern)的方法参数。
除按位非运算符外，
这些运算符都是二元左结合运算符。
按位非运算符是一元运算符。


介绍按位逻辑运算符

| 运算符 | 名称  | 描述                               |
| --- | --- | -------------------------------- |
| &   | 位与  | 产生两个操作数的按位与。两个操作位为1时才为1          |
| \|  | 位或  | 产生两个操作数的按位或。只要任意一个操作位为1结果就是1     |
| ^   | 位异或 | 产生两个操作数按位异或。仅当一个而不是两个操作数为1时结果位为1 |
| ~   | 位非  | 操作数的每个位都取反。获得二进制                 |



二元按位运算符是比较它两个操作数中每个位置对应的位，并根据逻辑操作设置返回值中的位。


示例：

```C#
const byte x = 12; y = 10;
sbyte a;

a = x & y;  // a = 8;
a = x | y;  // a = 14;
a = x ^ y;  // a = 6;
a = ~x;     // a = -13;
```

## 8. 移位运算符 >>

移位运算符就是把一个数的二进制码向左或向右移动，
- 因为存储数值的结构是有位数限制的，所以移动后会有一部分值被丢弃并需要补充一部分进来。
- 数值向左移动，那么尾部用0填充。
- 数值向右移动，这是需要分情况来分析:
	- 当数值类型为正数或无符号数时，最左步用0填充。
	- 当数值时负数是，因为在底层在最左边用1表示负数，那么此时需要在最左边添1.
- 左移相当于把这个数 \* 2,右移相当于把这个数/2；


移位运算符

| 运算符 | 名称  | 描述         |
| --- | --- | ---------- |
| <<  | 左移  | 位组向左移动给定数目 |
| >>  | 右移  | 位组向右移动给定数目 |

移位运算符语法:
Operand << Count  // Operand 左移Count位
Operand >> Count  // Operand 右移Count位

示例 :
 ```C#
int a, b, x = 14;

a = x << 3;  //左移
b = x >> 3;  //右移
```



## 9.赋值运算符 =

赋值运算符是二元右结合运算符

| 运算符 | 描述                                   |
| --- | ------------------------------------ |
| =   | 简单赋值，将=右边的值赋给左边                      |
| *=  | var \*= expr 等价于 var = var \* (expr) |
| /=  | var \/= expr 等价于 var = var / (expr)  |
| %=  | var \%= expr 等价于 var = var % (expr)  |
| +=  | var += expr 等价于 var = var + (expr)   |
| -=  | var -= expr 等价于 var = var - (expr)   |
| <<= | var <<= expr 等价于 var = var << (expr) |
| >>= | var >>= expr 等价于 var = var >> (expr) |
| &=  | var &= expr 等价于 var = var & (expr)   |
| ^=  | var ^= expr 等价于 var = var ^ (expr)   |
| \|= | var \|= expr 等价于 var = var \| (expr) |

因为赋值运算符是右结合的，说以先计算右值再计算左值。
`z = y = x = 10;` 先返回x 再返回y 再返回z


可放在赋值运算符的左值：
- 变量
- 属性
- 索引器
- 事件


复合赋值
形如
x = x + expr；

可以简化为 x += expr；
运算时先计算expr的数值情况。


## 10.条件运算符 ? :

`conditon ? var1 : var2;`
- condition  必须返回一个bool值
- 当bool值为真时返回 ：左边的值，如var1
- 当bool值为假时返回  : 右边的值， 如var2

## 11.一元算术运算符
即 + - 号
\+ num 正值
\- num 负值


## 12.用户定义的类型转换 ** 17章


# 4.运算符重载

## 1.运算符重载

C#运算符被用作处理预定义类型的操作数；
如果面对一个用户自定义类型，那么C#允许用户使用**运算符重载**，来重定义一个运算符处理用户自定义类型的运算符：


语法：
`public static ClassName operate x (param)`
- 方法必须是`public static`，必须写上类名，修饰符必须是`operate`，
- x为重载的运算符，如 + - * /
- 可以是一元运算符，可以是二元运算符，在参数中必须体现
	- 一元 `public static type operate + (class a)`
	- 二元 `public static type operate - (class a, class b)`
- 操作对象必须是类或结构


示例:
```C#
using System;

class AddNum
{
    public int TrueValue { get; set; }
    
    public static int operator -( AddNum x)
    {
        AddNum outcome = new AddNum();
        outcome.TrueValue = 0;
        return outcome.TrueValue;
    }

    public static AddNum operator +(AddNum x , AddNum y)
    {
        AddNum outcome = new AddNum();
        outcome.TrueValue = x.TrueValue + y.TrueValue;
        return outcome;
    }
}


class Program
{
    static void Main()
    {
        AddNum class1 = new AddNum();
        AddNum class2 = new AddNum();

        class1.TrueValue = 2;
        class2.TrueValue = 3;

        Console.WriteLine($"-class1 = {-class1}");
        Console.WriteLine($"The TrueValue of class + class2  = {(class1 + class2).TrueValue}");
    }
}

-class1 = 0
The TrueValue of class + class2  = 5


```

- 计算的结果最好使用一种中间实例类传递

## 2.运算符重载的限制

### 1. 可重载的运算符,和不可重载的运算符
一元： +、-、！、~、++、--、true、false
二元： +、-、\*、\/、%、&、|、^、<<、>>、\==、!=、>、<、>=、<=

不可重载的: 赋值运算符，逻辑运算符

### 2.运算符重载禁止的操作
- 不能创建新运算符
- 不能改变运算符的语法(怎么用，一元还是二元，前置和后置的处理逻辑)
- 运算符重载不能改变运算符的优先级
- 运算符重载不能改变运算符对预声明类型的处理逻辑


### 3.对前置后置运算符++、--的处理

-- ++ 操作数：
- 进行自增、自减操作
- 返回操作数


操作数-- ++:
1. 对于数值类型，现将操作数复制到表达式，再进行自增自减操作。
2. 对于引用类型，会将引用赋值到表达式，再进行自增自减操作。
	- 此时，因为赋值的是引用，自增自减操作后堆中的值会变化，那么对应结果也会与预期不同，造成的结果是 **++、--前置后置对引用类型的操作数结果没有影响**。

示例:
```C#

```


# 5. Typeof()运算符 \* 反射 GetType方法

..

# 6.nameof运算符
nameof（）运算符可以返回 变量、类成员、类的名称字符串

```C#
Console.WriteLine(nameof(变量名)); //返回这个变量名字符串
Console.WriteLine(nameof(类成员)); //返回类成员名字符串
Console.WriteLine(nameof(类)); //返回类的名字字符串
```

nameof的作用在于：
- 防止手打字符串可能出现的拼写错误
- 当对应类型的名字改变后，使用nameof()可以正确引用新名称
- 不能用于LINQ等的动态名称变化